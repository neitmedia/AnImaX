// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: animax.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_animax_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_animax_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_animax_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_animax_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[8]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_animax_2eproto;
namespace animax {
class Measurement;
struct MeasurementDefaultTypeInternal;
extern MeasurementDefaultTypeInternal _Measurement_default_instance_;
class Metadata;
struct MetadataDefaultTypeInternal;
extern MetadataDefaultTypeInternal _Metadata_default_instance_;
class ROI;
struct ROIDefaultTypeInternal;
extern ROIDefaultTypeInternal _ROI_default_instance_;
class ccd;
struct ccdDefaultTypeInternal;
extern ccdDefaultTypeInternal _ccd_default_instance_;
class ccdsettings;
struct ccdsettingsDefaultTypeInternal;
extern ccdsettingsDefaultTypeInternal _ccdsettings_default_instance_;
class preview;
struct previewDefaultTypeInternal;
extern previewDefaultTypeInternal _preview_default_instance_;
class scanstatus;
struct scanstatusDefaultTypeInternal;
extern scanstatusDefaultTypeInternal _scanstatus_default_instance_;
class sdd;
struct sddDefaultTypeInternal;
extern sddDefaultTypeInternal _sdd_default_instance_;
}  // namespace animax
PROTOBUF_NAMESPACE_OPEN
template<> ::animax::Measurement* Arena::CreateMaybeMessage<::animax::Measurement>(Arena*);
template<> ::animax::Metadata* Arena::CreateMaybeMessage<::animax::Metadata>(Arena*);
template<> ::animax::ROI* Arena::CreateMaybeMessage<::animax::ROI>(Arena*);
template<> ::animax::ccd* Arena::CreateMaybeMessage<::animax::ccd>(Arena*);
template<> ::animax::ccdsettings* Arena::CreateMaybeMessage<::animax::ccdsettings>(Arena*);
template<> ::animax::preview* Arena::CreateMaybeMessage<::animax::preview>(Arena*);
template<> ::animax::scanstatus* Arena::CreateMaybeMessage<::animax::scanstatus>(Arena*);
template<> ::animax::sdd* Arena::CreateMaybeMessage<::animax::sdd>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace animax {

// ===================================================================

class Measurement final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:animax.Measurement) */ {
 public:
  inline Measurement() : Measurement(nullptr) {}
  ~Measurement() override;
  explicit constexpr Measurement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Measurement(const Measurement& from);
  Measurement(Measurement&& from) noexcept
    : Measurement() {
    *this = ::std::move(from);
  }

  inline Measurement& operator=(const Measurement& from) {
    CopyFrom(from);
    return *this;
  }
  inline Measurement& operator=(Measurement&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Measurement& default_instance() {
    return *internal_default_instance();
  }
  static inline const Measurement* internal_default_instance() {
    return reinterpret_cast<const Measurement*>(
               &_Measurement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Measurement& a, Measurement& b) {
    a.Swap(&b);
  }
  inline void Swap(Measurement* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Measurement* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Measurement* New() const final {
    return new Measurement();
  }

  Measurement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Measurement>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Measurement& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Measurement& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Measurement* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "animax.Measurement";
  }
  protected:
  explicit Measurement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnergiesFieldNumber = 7,
    kROIdefinitionsFieldNumber = 8,
    kScantypeFieldNumber = 9,
    kDatasinkIPFieldNumber = 10,
    kSddIPFieldNumber = 12,
    kCcdIPFieldNumber = 14,
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
    kAquisitionTimeFieldNumber = 3,
    kEnergyCountFieldNumber = 4,
    kCcdheightFieldNumber = 5,
    kCcdwidthFieldNumber = 6,
    kDatasinkPortFieldNumber = 11,
    kSddPortFieldNumber = 13,
    kCcdPortFieldNumber = 15,
  };
  // repeated int32 energies = 7;
  int energies_size() const;
  private:
  int _internal_energies_size() const;
  public:
  void clear_energies();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_energies(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_energies() const;
  void _internal_add_energies(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_energies();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 energies(int index) const;
  void set_energies(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_energies(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      energies() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_energies();

  // string ROIdefinitions = 8;
  void clear_roidefinitions();
  const std::string& roidefinitions() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_roidefinitions(ArgT0&& arg0, ArgT... args);
  std::string* mutable_roidefinitions();
  PROTOBUF_MUST_USE_RESULT std::string* release_roidefinitions();
  void set_allocated_roidefinitions(std::string* roidefinitions);
  private:
  const std::string& _internal_roidefinitions() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_roidefinitions(const std::string& value);
  std::string* _internal_mutable_roidefinitions();
  public:

  // string scantype = 9;
  void clear_scantype();
  const std::string& scantype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_scantype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_scantype();
  PROTOBUF_MUST_USE_RESULT std::string* release_scantype();
  void set_allocated_scantype(std::string* scantype);
  private:
  const std::string& _internal_scantype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_scantype(const std::string& value);
  std::string* _internal_mutable_scantype();
  public:

  // string datasinkIP = 10;
  void clear_datasinkip();
  const std::string& datasinkip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_datasinkip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_datasinkip();
  PROTOBUF_MUST_USE_RESULT std::string* release_datasinkip();
  void set_allocated_datasinkip(std::string* datasinkip);
  private:
  const std::string& _internal_datasinkip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_datasinkip(const std::string& value);
  std::string* _internal_mutable_datasinkip();
  public:

  // string sddIP = 12;
  void clear_sddip();
  const std::string& sddip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sddip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sddip();
  PROTOBUF_MUST_USE_RESULT std::string* release_sddip();
  void set_allocated_sddip(std::string* sddip);
  private:
  const std::string& _internal_sddip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sddip(const std::string& value);
  std::string* _internal_mutable_sddip();
  public:

  // string ccdIP = 14;
  void clear_ccdip();
  const std::string& ccdip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ccdip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ccdip();
  PROTOBUF_MUST_USE_RESULT std::string* release_ccdip();
  void set_allocated_ccdip(std::string* ccdip);
  private:
  const std::string& _internal_ccdip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ccdip(const std::string& value);
  std::string* _internal_mutable_ccdip();
  public:

  // int32 width = 1;
  void clear_width();
  ::PROTOBUF_NAMESPACE_ID::int32 width() const;
  void set_width(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_width() const;
  void _internal_set_width(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 height = 2;
  void clear_height();
  ::PROTOBUF_NAMESPACE_ID::int32 height() const;
  void set_height(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_height() const;
  void _internal_set_height(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 aquisition_time = 3;
  void clear_aquisition_time();
  ::PROTOBUF_NAMESPACE_ID::int32 aquisition_time() const;
  void set_aquisition_time(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_aquisition_time() const;
  void _internal_set_aquisition_time(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 energy_count = 4;
  void clear_energy_count();
  ::PROTOBUF_NAMESPACE_ID::int32 energy_count() const;
  void set_energy_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_energy_count() const;
  void _internal_set_energy_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 ccdheight = 5;
  void clear_ccdheight();
  ::PROTOBUF_NAMESPACE_ID::int32 ccdheight() const;
  void set_ccdheight(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_ccdheight() const;
  void _internal_set_ccdheight(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 ccdwidth = 6;
  void clear_ccdwidth();
  ::PROTOBUF_NAMESPACE_ID::int32 ccdwidth() const;
  void set_ccdwidth(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_ccdwidth() const;
  void _internal_set_ccdwidth(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 datasinkPort = 11;
  void clear_datasinkport();
  ::PROTOBUF_NAMESPACE_ID::int32 datasinkport() const;
  void set_datasinkport(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_datasinkport() const;
  void _internal_set_datasinkport(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 sddPort = 13;
  void clear_sddport();
  ::PROTOBUF_NAMESPACE_ID::int32 sddport() const;
  void set_sddport(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_sddport() const;
  void _internal_set_sddport(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 ccdPort = 15;
  void clear_ccdport();
  ::PROTOBUF_NAMESPACE_ID::int32 ccdport() const;
  void set_ccdport(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_ccdport() const;
  void _internal_set_ccdport(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:animax.Measurement)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > energies_;
  mutable std::atomic<int> _energies_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr roidefinitions_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr scantype_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr datasinkip_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sddip_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ccdip_;
  ::PROTOBUF_NAMESPACE_ID::int32 width_;
  ::PROTOBUF_NAMESPACE_ID::int32 height_;
  ::PROTOBUF_NAMESPACE_ID::int32 aquisition_time_;
  ::PROTOBUF_NAMESPACE_ID::int32 energy_count_;
  ::PROTOBUF_NAMESPACE_ID::int32 ccdheight_;
  ::PROTOBUF_NAMESPACE_ID::int32 ccdwidth_;
  ::PROTOBUF_NAMESPACE_ID::int32 datasinkport_;
  ::PROTOBUF_NAMESPACE_ID::int32 sddport_;
  ::PROTOBUF_NAMESPACE_ID::int32 ccdport_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_animax_2eproto;
};
// -------------------------------------------------------------------

class Metadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:animax.Metadata) */ {
 public:
  inline Metadata() : Metadata(nullptr) {}
  ~Metadata() override;
  explicit constexpr Metadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Metadata(const Metadata& from);
  Metadata(Metadata&& from) noexcept
    : Metadata() {
    *this = ::std::move(from);
  }

  inline Metadata& operator=(const Metadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline Metadata& operator=(Metadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Metadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const Metadata* internal_default_instance() {
    return reinterpret_cast<const Metadata*>(
               &_Metadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Metadata& a, Metadata& b) {
    a.Swap(&b);
  }
  inline void Swap(Metadata* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Metadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Metadata* New() const final {
    return new Metadata();
  }

  Metadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Metadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Metadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Metadata& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Metadata* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "animax.Metadata";
  }
  protected:
  explicit Metadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAquisitionNumberFieldNumber = 1,
    kBeamlineEneryFieldNumber = 2,
  };
  // int32 aquisition_number = 1;
  void clear_aquisition_number();
  ::PROTOBUF_NAMESPACE_ID::int32 aquisition_number() const;
  void set_aquisition_number(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_aquisition_number() const;
  void _internal_set_aquisition_number(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 beamline_enery = 2;
  void clear_beamline_enery();
  ::PROTOBUF_NAMESPACE_ID::int32 beamline_enery() const;
  void set_beamline_enery(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_beamline_enery() const;
  void _internal_set_beamline_enery(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:animax.Metadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 aquisition_number_;
  ::PROTOBUF_NAMESPACE_ID::int32 beamline_enery_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_animax_2eproto;
};
// -------------------------------------------------------------------

class sdd final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:animax.sdd) */ {
 public:
  inline sdd() : sdd(nullptr) {}
  ~sdd() override;
  explicit constexpr sdd(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  sdd(const sdd& from);
  sdd(sdd&& from) noexcept
    : sdd() {
    *this = ::std::move(from);
  }

  inline sdd& operator=(const sdd& from) {
    CopyFrom(from);
    return *this;
  }
  inline sdd& operator=(sdd&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const sdd& default_instance() {
    return *internal_default_instance();
  }
  static inline const sdd* internal_default_instance() {
    return reinterpret_cast<const sdd*>(
               &_sdd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(sdd& a, sdd& b) {
    a.Swap(&b);
  }
  inline void Swap(sdd* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(sdd* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline sdd* New() const final {
    return new sdd();
  }

  sdd* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<sdd>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const sdd& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const sdd& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(sdd* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "animax.sdd";
  }
  protected:
  explicit sdd(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPixeldataFieldNumber = 1,
  };
  // bytes pixeldata = 1;
  void clear_pixeldata();
  const std::string& pixeldata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pixeldata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pixeldata();
  PROTOBUF_MUST_USE_RESULT std::string* release_pixeldata();
  void set_allocated_pixeldata(std::string* pixeldata);
  private:
  const std::string& _internal_pixeldata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pixeldata(const std::string& value);
  std::string* _internal_mutable_pixeldata();
  public:

  // @@protoc_insertion_point(class_scope:animax.sdd)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pixeldata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_animax_2eproto;
};
// -------------------------------------------------------------------

class ccd final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:animax.ccd) */ {
 public:
  inline ccd() : ccd(nullptr) {}
  ~ccd() override;
  explicit constexpr ccd(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ccd(const ccd& from);
  ccd(ccd&& from) noexcept
    : ccd() {
    *this = ::std::move(from);
  }

  inline ccd& operator=(const ccd& from) {
    CopyFrom(from);
    return *this;
  }
  inline ccd& operator=(ccd&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ccd& default_instance() {
    return *internal_default_instance();
  }
  static inline const ccd* internal_default_instance() {
    return reinterpret_cast<const ccd*>(
               &_ccd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ccd& a, ccd& b) {
    a.Swap(&b);
  }
  inline void Swap(ccd* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ccd* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ccd* New() const final {
    return new ccd();
  }

  ccd* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ccd>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ccd& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ccd& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ccd* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "animax.ccd";
  }
  protected:
  explicit ccd(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPixeldataFieldNumber = 2,
    kCntFieldNumber = 1,
  };
  // bytes pixeldata = 2;
  void clear_pixeldata();
  const std::string& pixeldata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pixeldata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pixeldata();
  PROTOBUF_MUST_USE_RESULT std::string* release_pixeldata();
  void set_allocated_pixeldata(std::string* pixeldata);
  private:
  const std::string& _internal_pixeldata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pixeldata(const std::string& value);
  std::string* _internal_mutable_pixeldata();
  public:

  // int32 cnt = 1;
  void clear_cnt();
  ::PROTOBUF_NAMESPACE_ID::int32 cnt() const;
  void set_cnt(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_cnt() const;
  void _internal_set_cnt(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:animax.ccd)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pixeldata_;
  ::PROTOBUF_NAMESPACE_ID::int32 cnt_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_animax_2eproto;
};
// -------------------------------------------------------------------

class ccdsettings final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:animax.ccdsettings) */ {
 public:
  inline ccdsettings() : ccdsettings(nullptr) {}
  ~ccdsettings() override;
  explicit constexpr ccdsettings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ccdsettings(const ccdsettings& from);
  ccdsettings(ccdsettings&& from) noexcept
    : ccdsettings() {
    *this = ::std::move(from);
  }

  inline ccdsettings& operator=(const ccdsettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline ccdsettings& operator=(ccdsettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ccdsettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const ccdsettings* internal_default_instance() {
    return reinterpret_cast<const ccdsettings*>(
               &_ccdsettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ccdsettings& a, ccdsettings& b) {
    a.Swap(&b);
  }
  inline void Swap(ccdsettings* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ccdsettings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ccdsettings* New() const final {
    return new ccdsettings();
  }

  ccdsettings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ccdsettings>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ccdsettings& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ccdsettings& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ccdsettings* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "animax.ccdsettings";
  }
  protected:
  explicit ccdsettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
  };
  // int32 width = 1;
  void clear_width();
  ::PROTOBUF_NAMESPACE_ID::int32 width() const;
  void set_width(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_width() const;
  void _internal_set_width(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 height = 2;
  void clear_height();
  ::PROTOBUF_NAMESPACE_ID::int32 height() const;
  void set_height(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_height() const;
  void _internal_set_height(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:animax.ccdsettings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 width_;
  ::PROTOBUF_NAMESPACE_ID::int32 height_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_animax_2eproto;
};
// -------------------------------------------------------------------

class preview final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:animax.preview) */ {
 public:
  inline preview() : preview(nullptr) {}
  ~preview() override;
  explicit constexpr preview(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  preview(const preview& from);
  preview(preview&& from) noexcept
    : preview() {
    *this = ::std::move(from);
  }

  inline preview& operator=(const preview& from) {
    CopyFrom(from);
    return *this;
  }
  inline preview& operator=(preview&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const preview& default_instance() {
    return *internal_default_instance();
  }
  static inline const preview* internal_default_instance() {
    return reinterpret_cast<const preview*>(
               &_preview_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(preview& a, preview& b) {
    a.Swap(&b);
  }
  inline void Swap(preview* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(preview* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline preview* New() const final {
    return new preview();
  }

  preview* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<preview>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const preview& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const preview& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(preview* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "animax.preview";
  }
  protected:
  explicit preview(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kPreviewdataFieldNumber = 2,
  };
  // string type = 1;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_MUST_USE_RESULT std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // bytes previewdata = 2;
  void clear_previewdata();
  const std::string& previewdata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_previewdata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_previewdata();
  PROTOBUF_MUST_USE_RESULT std::string* release_previewdata();
  void set_allocated_previewdata(std::string* previewdata);
  private:
  const std::string& _internal_previewdata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_previewdata(const std::string& value);
  std::string* _internal_mutable_previewdata();
  public:

  // @@protoc_insertion_point(class_scope:animax.preview)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr previewdata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_animax_2eproto;
};
// -------------------------------------------------------------------

class ROI final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:animax.ROI) */ {
 public:
  inline ROI() : ROI(nullptr) {}
  ~ROI() override;
  explicit constexpr ROI(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ROI(const ROI& from);
  ROI(ROI&& from) noexcept
    : ROI() {
    *this = ::std::move(from);
  }

  inline ROI& operator=(const ROI& from) {
    CopyFrom(from);
    return *this;
  }
  inline ROI& operator=(ROI&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ROI& default_instance() {
    return *internal_default_instance();
  }
  static inline const ROI* internal_default_instance() {
    return reinterpret_cast<const ROI*>(
               &_ROI_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ROI& a, ROI& b) {
    a.Swap(&b);
  }
  inline void Swap(ROI* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ROI* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ROI* New() const final {
    return new ROI();
  }

  ROI* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ROI>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ROI& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ROI& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ROI* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "animax.ROI";
  }
  protected:
  explicit ROI(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kElementFieldNumber = 1,
    kLineFieldNumber = 2,
    kRoidataFieldNumber = 3,
  };
  // string element = 1;
  void clear_element();
  const std::string& element() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_element(ArgT0&& arg0, ArgT... args);
  std::string* mutable_element();
  PROTOBUF_MUST_USE_RESULT std::string* release_element();
  void set_allocated_element(std::string* element);
  private:
  const std::string& _internal_element() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_element(const std::string& value);
  std::string* _internal_mutable_element();
  public:

  // string line = 2;
  void clear_line();
  const std::string& line() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_line(ArgT0&& arg0, ArgT... args);
  std::string* mutable_line();
  PROTOBUF_MUST_USE_RESULT std::string* release_line();
  void set_allocated_line(std::string* line);
  private:
  const std::string& _internal_line() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_line(const std::string& value);
  std::string* _internal_mutable_line();
  public:

  // bytes roidata = 3;
  void clear_roidata();
  const std::string& roidata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_roidata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_roidata();
  PROTOBUF_MUST_USE_RESULT std::string* release_roidata();
  void set_allocated_roidata(std::string* roidata);
  private:
  const std::string& _internal_roidata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_roidata(const std::string& value);
  std::string* _internal_mutable_roidata();
  public:

  // @@protoc_insertion_point(class_scope:animax.ROI)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr element_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr line_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr roidata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_animax_2eproto;
};
// -------------------------------------------------------------------

class scanstatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:animax.scanstatus) */ {
 public:
  inline scanstatus() : scanstatus(nullptr) {}
  ~scanstatus() override;
  explicit constexpr scanstatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  scanstatus(const scanstatus& from);
  scanstatus(scanstatus&& from) noexcept
    : scanstatus() {
    *this = ::std::move(from);
  }

  inline scanstatus& operator=(const scanstatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline scanstatus& operator=(scanstatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const scanstatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const scanstatus* internal_default_instance() {
    return reinterpret_cast<const scanstatus*>(
               &_scanstatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(scanstatus& a, scanstatus& b) {
    a.Swap(&b);
  }
  inline void Swap(scanstatus* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(scanstatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline scanstatus* New() const final {
    return new scanstatus();
  }

  scanstatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<scanstatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const scanstatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const scanstatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(scanstatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "animax.scanstatus";
  }
  protected:
  explicit scanstatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // string status = 1;
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // @@protoc_insertion_point(class_scope:animax.scanstatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_animax_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Measurement

// int32 width = 1;
inline void Measurement::clear_width() {
  width_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Measurement::_internal_width() const {
  return width_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Measurement::width() const {
  // @@protoc_insertion_point(field_get:animax.Measurement.width)
  return _internal_width();
}
inline void Measurement::_internal_set_width(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  width_ = value;
}
inline void Measurement::set_width(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:animax.Measurement.width)
}

// int32 height = 2;
inline void Measurement::clear_height() {
  height_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Measurement::_internal_height() const {
  return height_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Measurement::height() const {
  // @@protoc_insertion_point(field_get:animax.Measurement.height)
  return _internal_height();
}
inline void Measurement::_internal_set_height(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  height_ = value;
}
inline void Measurement::set_height(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:animax.Measurement.height)
}

// int32 aquisition_time = 3;
inline void Measurement::clear_aquisition_time() {
  aquisition_time_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Measurement::_internal_aquisition_time() const {
  return aquisition_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Measurement::aquisition_time() const {
  // @@protoc_insertion_point(field_get:animax.Measurement.aquisition_time)
  return _internal_aquisition_time();
}
inline void Measurement::_internal_set_aquisition_time(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  aquisition_time_ = value;
}
inline void Measurement::set_aquisition_time(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_aquisition_time(value);
  // @@protoc_insertion_point(field_set:animax.Measurement.aquisition_time)
}

// int32 energy_count = 4;
inline void Measurement::clear_energy_count() {
  energy_count_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Measurement::_internal_energy_count() const {
  return energy_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Measurement::energy_count() const {
  // @@protoc_insertion_point(field_get:animax.Measurement.energy_count)
  return _internal_energy_count();
}
inline void Measurement::_internal_set_energy_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  energy_count_ = value;
}
inline void Measurement::set_energy_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_energy_count(value);
  // @@protoc_insertion_point(field_set:animax.Measurement.energy_count)
}

// int32 ccdheight = 5;
inline void Measurement::clear_ccdheight() {
  ccdheight_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Measurement::_internal_ccdheight() const {
  return ccdheight_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Measurement::ccdheight() const {
  // @@protoc_insertion_point(field_get:animax.Measurement.ccdheight)
  return _internal_ccdheight();
}
inline void Measurement::_internal_set_ccdheight(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  ccdheight_ = value;
}
inline void Measurement::set_ccdheight(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_ccdheight(value);
  // @@protoc_insertion_point(field_set:animax.Measurement.ccdheight)
}

// int32 ccdwidth = 6;
inline void Measurement::clear_ccdwidth() {
  ccdwidth_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Measurement::_internal_ccdwidth() const {
  return ccdwidth_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Measurement::ccdwidth() const {
  // @@protoc_insertion_point(field_get:animax.Measurement.ccdwidth)
  return _internal_ccdwidth();
}
inline void Measurement::_internal_set_ccdwidth(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  ccdwidth_ = value;
}
inline void Measurement::set_ccdwidth(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_ccdwidth(value);
  // @@protoc_insertion_point(field_set:animax.Measurement.ccdwidth)
}

// repeated int32 energies = 7;
inline int Measurement::_internal_energies_size() const {
  return energies_.size();
}
inline int Measurement::energies_size() const {
  return _internal_energies_size();
}
inline void Measurement::clear_energies() {
  energies_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Measurement::_internal_energies(int index) const {
  return energies_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Measurement::energies(int index) const {
  // @@protoc_insertion_point(field_get:animax.Measurement.energies)
  return _internal_energies(index);
}
inline void Measurement::set_energies(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  energies_.Set(index, value);
  // @@protoc_insertion_point(field_set:animax.Measurement.energies)
}
inline void Measurement::_internal_add_energies(::PROTOBUF_NAMESPACE_ID::int32 value) {
  energies_.Add(value);
}
inline void Measurement::add_energies(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_energies(value);
  // @@protoc_insertion_point(field_add:animax.Measurement.energies)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
Measurement::_internal_energies() const {
  return energies_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
Measurement::energies() const {
  // @@protoc_insertion_point(field_list:animax.Measurement.energies)
  return _internal_energies();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
Measurement::_internal_mutable_energies() {
  return &energies_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
Measurement::mutable_energies() {
  // @@protoc_insertion_point(field_mutable_list:animax.Measurement.energies)
  return _internal_mutable_energies();
}

// string ROIdefinitions = 8;
inline void Measurement::clear_roidefinitions() {
  roidefinitions_.ClearToEmpty();
}
inline const std::string& Measurement::roidefinitions() const {
  // @@protoc_insertion_point(field_get:animax.Measurement.ROIdefinitions)
  return _internal_roidefinitions();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Measurement::set_roidefinitions(ArgT0&& arg0, ArgT... args) {
 
 roidefinitions_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:animax.Measurement.ROIdefinitions)
}
inline std::string* Measurement::mutable_roidefinitions() {
  std::string* _s = _internal_mutable_roidefinitions();
  // @@protoc_insertion_point(field_mutable:animax.Measurement.ROIdefinitions)
  return _s;
}
inline const std::string& Measurement::_internal_roidefinitions() const {
  return roidefinitions_.Get();
}
inline void Measurement::_internal_set_roidefinitions(const std::string& value) {
  
  roidefinitions_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Measurement::_internal_mutable_roidefinitions() {
  
  return roidefinitions_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Measurement::release_roidefinitions() {
  // @@protoc_insertion_point(field_release:animax.Measurement.ROIdefinitions)
  return roidefinitions_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Measurement::set_allocated_roidefinitions(std::string* roidefinitions) {
  if (roidefinitions != nullptr) {
    
  } else {
    
  }
  roidefinitions_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), roidefinitions,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:animax.Measurement.ROIdefinitions)
}

// string scantype = 9;
inline void Measurement::clear_scantype() {
  scantype_.ClearToEmpty();
}
inline const std::string& Measurement::scantype() const {
  // @@protoc_insertion_point(field_get:animax.Measurement.scantype)
  return _internal_scantype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Measurement::set_scantype(ArgT0&& arg0, ArgT... args) {
 
 scantype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:animax.Measurement.scantype)
}
inline std::string* Measurement::mutable_scantype() {
  std::string* _s = _internal_mutable_scantype();
  // @@protoc_insertion_point(field_mutable:animax.Measurement.scantype)
  return _s;
}
inline const std::string& Measurement::_internal_scantype() const {
  return scantype_.Get();
}
inline void Measurement::_internal_set_scantype(const std::string& value) {
  
  scantype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Measurement::_internal_mutable_scantype() {
  
  return scantype_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Measurement::release_scantype() {
  // @@protoc_insertion_point(field_release:animax.Measurement.scantype)
  return scantype_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Measurement::set_allocated_scantype(std::string* scantype) {
  if (scantype != nullptr) {
    
  } else {
    
  }
  scantype_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), scantype,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:animax.Measurement.scantype)
}

// string datasinkIP = 10;
inline void Measurement::clear_datasinkip() {
  datasinkip_.ClearToEmpty();
}
inline const std::string& Measurement::datasinkip() const {
  // @@protoc_insertion_point(field_get:animax.Measurement.datasinkIP)
  return _internal_datasinkip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Measurement::set_datasinkip(ArgT0&& arg0, ArgT... args) {
 
 datasinkip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:animax.Measurement.datasinkIP)
}
inline std::string* Measurement::mutable_datasinkip() {
  std::string* _s = _internal_mutable_datasinkip();
  // @@protoc_insertion_point(field_mutable:animax.Measurement.datasinkIP)
  return _s;
}
inline const std::string& Measurement::_internal_datasinkip() const {
  return datasinkip_.Get();
}
inline void Measurement::_internal_set_datasinkip(const std::string& value) {
  
  datasinkip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Measurement::_internal_mutable_datasinkip() {
  
  return datasinkip_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Measurement::release_datasinkip() {
  // @@protoc_insertion_point(field_release:animax.Measurement.datasinkIP)
  return datasinkip_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Measurement::set_allocated_datasinkip(std::string* datasinkip) {
  if (datasinkip != nullptr) {
    
  } else {
    
  }
  datasinkip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), datasinkip,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:animax.Measurement.datasinkIP)
}

// int32 datasinkPort = 11;
inline void Measurement::clear_datasinkport() {
  datasinkport_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Measurement::_internal_datasinkport() const {
  return datasinkport_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Measurement::datasinkport() const {
  // @@protoc_insertion_point(field_get:animax.Measurement.datasinkPort)
  return _internal_datasinkport();
}
inline void Measurement::_internal_set_datasinkport(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  datasinkport_ = value;
}
inline void Measurement::set_datasinkport(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_datasinkport(value);
  // @@protoc_insertion_point(field_set:animax.Measurement.datasinkPort)
}

// string sddIP = 12;
inline void Measurement::clear_sddip() {
  sddip_.ClearToEmpty();
}
inline const std::string& Measurement::sddip() const {
  // @@protoc_insertion_point(field_get:animax.Measurement.sddIP)
  return _internal_sddip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Measurement::set_sddip(ArgT0&& arg0, ArgT... args) {
 
 sddip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:animax.Measurement.sddIP)
}
inline std::string* Measurement::mutable_sddip() {
  std::string* _s = _internal_mutable_sddip();
  // @@protoc_insertion_point(field_mutable:animax.Measurement.sddIP)
  return _s;
}
inline const std::string& Measurement::_internal_sddip() const {
  return sddip_.Get();
}
inline void Measurement::_internal_set_sddip(const std::string& value) {
  
  sddip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Measurement::_internal_mutable_sddip() {
  
  return sddip_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Measurement::release_sddip() {
  // @@protoc_insertion_point(field_release:animax.Measurement.sddIP)
  return sddip_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Measurement::set_allocated_sddip(std::string* sddip) {
  if (sddip != nullptr) {
    
  } else {
    
  }
  sddip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sddip,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:animax.Measurement.sddIP)
}

// int32 sddPort = 13;
inline void Measurement::clear_sddport() {
  sddport_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Measurement::_internal_sddport() const {
  return sddport_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Measurement::sddport() const {
  // @@protoc_insertion_point(field_get:animax.Measurement.sddPort)
  return _internal_sddport();
}
inline void Measurement::_internal_set_sddport(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  sddport_ = value;
}
inline void Measurement::set_sddport(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_sddport(value);
  // @@protoc_insertion_point(field_set:animax.Measurement.sddPort)
}

// string ccdIP = 14;
inline void Measurement::clear_ccdip() {
  ccdip_.ClearToEmpty();
}
inline const std::string& Measurement::ccdip() const {
  // @@protoc_insertion_point(field_get:animax.Measurement.ccdIP)
  return _internal_ccdip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Measurement::set_ccdip(ArgT0&& arg0, ArgT... args) {
 
 ccdip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:animax.Measurement.ccdIP)
}
inline std::string* Measurement::mutable_ccdip() {
  std::string* _s = _internal_mutable_ccdip();
  // @@protoc_insertion_point(field_mutable:animax.Measurement.ccdIP)
  return _s;
}
inline const std::string& Measurement::_internal_ccdip() const {
  return ccdip_.Get();
}
inline void Measurement::_internal_set_ccdip(const std::string& value) {
  
  ccdip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Measurement::_internal_mutable_ccdip() {
  
  return ccdip_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Measurement::release_ccdip() {
  // @@protoc_insertion_point(field_release:animax.Measurement.ccdIP)
  return ccdip_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Measurement::set_allocated_ccdip(std::string* ccdip) {
  if (ccdip != nullptr) {
    
  } else {
    
  }
  ccdip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ccdip,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:animax.Measurement.ccdIP)
}

// int32 ccdPort = 15;
inline void Measurement::clear_ccdport() {
  ccdport_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Measurement::_internal_ccdport() const {
  return ccdport_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Measurement::ccdport() const {
  // @@protoc_insertion_point(field_get:animax.Measurement.ccdPort)
  return _internal_ccdport();
}
inline void Measurement::_internal_set_ccdport(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  ccdport_ = value;
}
inline void Measurement::set_ccdport(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_ccdport(value);
  // @@protoc_insertion_point(field_set:animax.Measurement.ccdPort)
}

// -------------------------------------------------------------------

// Metadata

// int32 aquisition_number = 1;
inline void Metadata::clear_aquisition_number() {
  aquisition_number_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Metadata::_internal_aquisition_number() const {
  return aquisition_number_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Metadata::aquisition_number() const {
  // @@protoc_insertion_point(field_get:animax.Metadata.aquisition_number)
  return _internal_aquisition_number();
}
inline void Metadata::_internal_set_aquisition_number(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  aquisition_number_ = value;
}
inline void Metadata::set_aquisition_number(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_aquisition_number(value);
  // @@protoc_insertion_point(field_set:animax.Metadata.aquisition_number)
}

// int32 beamline_enery = 2;
inline void Metadata::clear_beamline_enery() {
  beamline_enery_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Metadata::_internal_beamline_enery() const {
  return beamline_enery_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Metadata::beamline_enery() const {
  // @@protoc_insertion_point(field_get:animax.Metadata.beamline_enery)
  return _internal_beamline_enery();
}
inline void Metadata::_internal_set_beamline_enery(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  beamline_enery_ = value;
}
inline void Metadata::set_beamline_enery(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_beamline_enery(value);
  // @@protoc_insertion_point(field_set:animax.Metadata.beamline_enery)
}

// -------------------------------------------------------------------

// sdd

// bytes pixeldata = 1;
inline void sdd::clear_pixeldata() {
  pixeldata_.ClearToEmpty();
}
inline const std::string& sdd::pixeldata() const {
  // @@protoc_insertion_point(field_get:animax.sdd.pixeldata)
  return _internal_pixeldata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void sdd::set_pixeldata(ArgT0&& arg0, ArgT... args) {
 
 pixeldata_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:animax.sdd.pixeldata)
}
inline std::string* sdd::mutable_pixeldata() {
  std::string* _s = _internal_mutable_pixeldata();
  // @@protoc_insertion_point(field_mutable:animax.sdd.pixeldata)
  return _s;
}
inline const std::string& sdd::_internal_pixeldata() const {
  return pixeldata_.Get();
}
inline void sdd::_internal_set_pixeldata(const std::string& value) {
  
  pixeldata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* sdd::_internal_mutable_pixeldata() {
  
  return pixeldata_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* sdd::release_pixeldata() {
  // @@protoc_insertion_point(field_release:animax.sdd.pixeldata)
  return pixeldata_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void sdd::set_allocated_pixeldata(std::string* pixeldata) {
  if (pixeldata != nullptr) {
    
  } else {
    
  }
  pixeldata_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pixeldata,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:animax.sdd.pixeldata)
}

// -------------------------------------------------------------------

// ccd

// int32 cnt = 1;
inline void ccd::clear_cnt() {
  cnt_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ccd::_internal_cnt() const {
  return cnt_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ccd::cnt() const {
  // @@protoc_insertion_point(field_get:animax.ccd.cnt)
  return _internal_cnt();
}
inline void ccd::_internal_set_cnt(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  cnt_ = value;
}
inline void ccd::set_cnt(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_cnt(value);
  // @@protoc_insertion_point(field_set:animax.ccd.cnt)
}

// bytes pixeldata = 2;
inline void ccd::clear_pixeldata() {
  pixeldata_.ClearToEmpty();
}
inline const std::string& ccd::pixeldata() const {
  // @@protoc_insertion_point(field_get:animax.ccd.pixeldata)
  return _internal_pixeldata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ccd::set_pixeldata(ArgT0&& arg0, ArgT... args) {
 
 pixeldata_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:animax.ccd.pixeldata)
}
inline std::string* ccd::mutable_pixeldata() {
  std::string* _s = _internal_mutable_pixeldata();
  // @@protoc_insertion_point(field_mutable:animax.ccd.pixeldata)
  return _s;
}
inline const std::string& ccd::_internal_pixeldata() const {
  return pixeldata_.Get();
}
inline void ccd::_internal_set_pixeldata(const std::string& value) {
  
  pixeldata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ccd::_internal_mutable_pixeldata() {
  
  return pixeldata_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ccd::release_pixeldata() {
  // @@protoc_insertion_point(field_release:animax.ccd.pixeldata)
  return pixeldata_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ccd::set_allocated_pixeldata(std::string* pixeldata) {
  if (pixeldata != nullptr) {
    
  } else {
    
  }
  pixeldata_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pixeldata,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:animax.ccd.pixeldata)
}

// -------------------------------------------------------------------

// ccdsettings

// int32 width = 1;
inline void ccdsettings::clear_width() {
  width_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ccdsettings::_internal_width() const {
  return width_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ccdsettings::width() const {
  // @@protoc_insertion_point(field_get:animax.ccdsettings.width)
  return _internal_width();
}
inline void ccdsettings::_internal_set_width(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  width_ = value;
}
inline void ccdsettings::set_width(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:animax.ccdsettings.width)
}

// int32 height = 2;
inline void ccdsettings::clear_height() {
  height_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ccdsettings::_internal_height() const {
  return height_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ccdsettings::height() const {
  // @@protoc_insertion_point(field_get:animax.ccdsettings.height)
  return _internal_height();
}
inline void ccdsettings::_internal_set_height(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  height_ = value;
}
inline void ccdsettings::set_height(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:animax.ccdsettings.height)
}

// -------------------------------------------------------------------

// preview

// string type = 1;
inline void preview::clear_type() {
  type_.ClearToEmpty();
}
inline const std::string& preview::type() const {
  // @@protoc_insertion_point(field_get:animax.preview.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void preview::set_type(ArgT0&& arg0, ArgT... args) {
 
 type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:animax.preview.type)
}
inline std::string* preview::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:animax.preview.type)
  return _s;
}
inline const std::string& preview::_internal_type() const {
  return type_.Get();
}
inline void preview::_internal_set_type(const std::string& value) {
  
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* preview::_internal_mutable_type() {
  
  return type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* preview::release_type() {
  // @@protoc_insertion_point(field_release:animax.preview.type)
  return type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void preview::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:animax.preview.type)
}

// bytes previewdata = 2;
inline void preview::clear_previewdata() {
  previewdata_.ClearToEmpty();
}
inline const std::string& preview::previewdata() const {
  // @@protoc_insertion_point(field_get:animax.preview.previewdata)
  return _internal_previewdata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void preview::set_previewdata(ArgT0&& arg0, ArgT... args) {
 
 previewdata_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:animax.preview.previewdata)
}
inline std::string* preview::mutable_previewdata() {
  std::string* _s = _internal_mutable_previewdata();
  // @@protoc_insertion_point(field_mutable:animax.preview.previewdata)
  return _s;
}
inline const std::string& preview::_internal_previewdata() const {
  return previewdata_.Get();
}
inline void preview::_internal_set_previewdata(const std::string& value) {
  
  previewdata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* preview::_internal_mutable_previewdata() {
  
  return previewdata_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* preview::release_previewdata() {
  // @@protoc_insertion_point(field_release:animax.preview.previewdata)
  return previewdata_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void preview::set_allocated_previewdata(std::string* previewdata) {
  if (previewdata != nullptr) {
    
  } else {
    
  }
  previewdata_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), previewdata,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:animax.preview.previewdata)
}

// -------------------------------------------------------------------

// ROI

// string element = 1;
inline void ROI::clear_element() {
  element_.ClearToEmpty();
}
inline const std::string& ROI::element() const {
  // @@protoc_insertion_point(field_get:animax.ROI.element)
  return _internal_element();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ROI::set_element(ArgT0&& arg0, ArgT... args) {
 
 element_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:animax.ROI.element)
}
inline std::string* ROI::mutable_element() {
  std::string* _s = _internal_mutable_element();
  // @@protoc_insertion_point(field_mutable:animax.ROI.element)
  return _s;
}
inline const std::string& ROI::_internal_element() const {
  return element_.Get();
}
inline void ROI::_internal_set_element(const std::string& value) {
  
  element_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ROI::_internal_mutable_element() {
  
  return element_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ROI::release_element() {
  // @@protoc_insertion_point(field_release:animax.ROI.element)
  return element_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ROI::set_allocated_element(std::string* element) {
  if (element != nullptr) {
    
  } else {
    
  }
  element_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), element,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:animax.ROI.element)
}

// string line = 2;
inline void ROI::clear_line() {
  line_.ClearToEmpty();
}
inline const std::string& ROI::line() const {
  // @@protoc_insertion_point(field_get:animax.ROI.line)
  return _internal_line();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ROI::set_line(ArgT0&& arg0, ArgT... args) {
 
 line_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:animax.ROI.line)
}
inline std::string* ROI::mutable_line() {
  std::string* _s = _internal_mutable_line();
  // @@protoc_insertion_point(field_mutable:animax.ROI.line)
  return _s;
}
inline const std::string& ROI::_internal_line() const {
  return line_.Get();
}
inline void ROI::_internal_set_line(const std::string& value) {
  
  line_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ROI::_internal_mutable_line() {
  
  return line_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ROI::release_line() {
  // @@protoc_insertion_point(field_release:animax.ROI.line)
  return line_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ROI::set_allocated_line(std::string* line) {
  if (line != nullptr) {
    
  } else {
    
  }
  line_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), line,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:animax.ROI.line)
}

// bytes roidata = 3;
inline void ROI::clear_roidata() {
  roidata_.ClearToEmpty();
}
inline const std::string& ROI::roidata() const {
  // @@protoc_insertion_point(field_get:animax.ROI.roidata)
  return _internal_roidata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ROI::set_roidata(ArgT0&& arg0, ArgT... args) {
 
 roidata_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:animax.ROI.roidata)
}
inline std::string* ROI::mutable_roidata() {
  std::string* _s = _internal_mutable_roidata();
  // @@protoc_insertion_point(field_mutable:animax.ROI.roidata)
  return _s;
}
inline const std::string& ROI::_internal_roidata() const {
  return roidata_.Get();
}
inline void ROI::_internal_set_roidata(const std::string& value) {
  
  roidata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ROI::_internal_mutable_roidata() {
  
  return roidata_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ROI::release_roidata() {
  // @@protoc_insertion_point(field_release:animax.ROI.roidata)
  return roidata_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ROI::set_allocated_roidata(std::string* roidata) {
  if (roidata != nullptr) {
    
  } else {
    
  }
  roidata_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), roidata,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:animax.ROI.roidata)
}

// -------------------------------------------------------------------

// scanstatus

// string status = 1;
inline void scanstatus::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& scanstatus::status() const {
  // @@protoc_insertion_point(field_get:animax.scanstatus.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void scanstatus::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:animax.scanstatus.status)
}
inline std::string* scanstatus::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:animax.scanstatus.status)
  return _s;
}
inline const std::string& scanstatus::_internal_status() const {
  return status_.Get();
}
inline void scanstatus::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* scanstatus::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* scanstatus::release_status() {
  // @@protoc_insertion_point(field_release:animax.scanstatus.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void scanstatus::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:animax.scanstatus.status)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace animax

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_animax_2eproto
